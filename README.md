# Simple Math Programming Language (SMPL) for the Web

SMPL is a math-oriented programming language that can be interpreted in the browser. Its primary use is for the **mathe:buddy** app.

SMPL has the following advantages, compared to other languages (e.g. Python, Octave, Maxima):

- No server is required. Code is executed at client-side. There is no need to install anything. On the other hand, pure server side execution can be done with [node](https://nodejs.org/).
- Simple syntax with intrinsic data types for math.
- No need to import math libraries explicitly.

SMPL uses `mathJS` (and later on e.g. TensorFlow) for core calculations.

SMPL is easily **extendible**. Refer to the _Developer Notes_ below.

# Playground

Visit [https://mathebuddy.github.io/mathebuddy-smpl/](https://mathebuddy.github.io/mathebuddy-smpl/) and have fun!

# Language Reference

The reference guide to the _Simple Math Programming Language (SMPL)_ can be found [here](https://app.f07-its.fh-koeln.de/docs-smpl.html).

# Installation

```
npm install @mathebuddy/mathebuddy-smpl
```

## NodeJS Example

You can also run code on [https://npm.runkit.com/](https://npm.runkit.com/); without installation.

Copy the following code to the link above and run it!

```javascript
var SMPL = require('@mathebuddy/mathebuddy-smpl');

let src = `
// create two (3x3)-matrices A and B, with random
// (integral) entries in range [-5,5] without zero.
let A:B = randZ<3,3>(-5,5);
let C = A * B;
`;

let variables = SMPL.interpret(src);

for (let v of variables) {
  console.log(v.id + ' = ' + v.value.toString());
}
```

# Developer Notes

File [`src/prototypes.ts`](https://github.com/mathebuddy/mathebuddy-smpl/blob/main/src/prototypes.ts) declares all function prototypes. This file is autogenerated. The definition and implementation can be found in files [`src/interpret_*.ts`.](https://github.com/mathebuddy/mathebuddy-smpl/blob/main/src/interpret_basic.ts)

Example: Create support for a function `abs(..)` for real and complex numbers.

Since the function is overloaded with two different types (and JavaScript does not support function overloading), each must be mapped onto a different function ID (`_absReal` and `_absComplex`).

- Insert the following lines as new method into file `src/interpret_basic.ts`

  ```typescript
  //G abs(x:REAL):REAL -> _absReal;
  _absReal(x:number): number {
    return Math.abs(x);
    // direct implementation: return x < 0 ? -x : x;
  }
  ```

  The method uses Vanilla JavaScript function `Math.abs(..)` to calculate the absolute values of a real number.

- Insert the following lines as new method into file `src/interpret_complex.ts`:

  ```typescript
  //G abs(x:COMPLEX):REAL -> _absComplex;
  _absReal(x:number): number {
    const x_mathjs = x.toMathjs();
    return mathjs.abs(x_mathjs) as number;
    // direct implementation: return Math.sqrt(x.real*x.real + x.imag*x.imag);
  }
  ```

  The method uses MathJS to calculate the absolute value of a complex number. Classes `Complex`, `Matrix`, ... provide type conversion methods.

- Update `src/prototypes.ts` by running `./build.sh`

Any third party math library written (or compiled to) JavaScript may be included, but increases the download size of the library (currently less than 200 kiB).
